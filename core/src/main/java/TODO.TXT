=== TODO

=== LATER

- open-api...

=== NOW

node 6.1.0 -> 21.1.0
npm 3.8.6 -> 10.2.0

Alle komponenten & alle instanzen haben administrative komponente:
ich brauhe nur die instanzen einer komponente

hab ich: das ist die serviceadress mit uris...

Also: ServiceManger + [:<uri>]

ServiceManager cached
  <service>:<channel> -> proxy ( mkt invocation handler)


  acquireService(<class>, <channel>)

ChannelinvocationHandler cached
   <service>[:<preferredChannel>] ->ChannelinvocationHandler

ChannelManager cached
   <service>[:<preferredChannel>] -> Channel

Channel.resolve()

client -> server
            -> fragt alle instanzen eines services

serviceIds = {s1, s2, s3 }


componentX -> call(<service>) -> macht erneut call auf 2. adresse

server macht acquireService(FooComponent.::class) // GEHT NICHT

PROBLEM
- proxy geht nur, wenn klasse bekannt
- ein server kann meherer compoennts hosten, und dann?

interface ComponentIntrospection {

}

+ restservice

introspect(compoenntName: String) !



=== DONE

- load balancer
- irgendetwas mit post? body
- exception handler
- channelbuilder LIST!!!
- mvn package
- kotlin
- publish ( github package )
- log delta
- list bodyToFlux(class).toList()
- test mono
- delta alte werte??
- customize... nicht build!
- delta einbauen bzw. logik validieren! -> resolve???
- resolve -> im channelinvhandle sucks -> kein channel name!!!!
- dispatch channel
- delta
- foo.bar
- common serviuce impl
- cluster vs. local
- github action
- initialer test
- channel nicht im componentdescriptor
- customize channel
- watchdog...
- http -> rest!!! URI reicht nicht
- http != https???
- mehrere module
- lib
- channel als meta!
- requestmappig an der klasse...
- consul properties??
- GetMapping erzeugen?
- wie geht jetzt local: initiale bean vs acquire?????
- lifecycle aufschreiben!
- ConsulAutoServiceRegistration
- component registratur ( auto off )
- component health
- component auflösen
- call component http...
- wie geht der actuator??
- component lifecylce
- factor???
- exceptions: build / runtime, local, remote, ..
- DELETE, ...
- methodanalyzer aufräumen
- logging
- injection?
- report
- neue annotation + supports={"http"}
- LocalChannel singleton
- parameter name
- body
- bod response
- localhost?????
- wo annotations
- http channel anfangen & ausprobieren
- add pom...
- homebrew
- consul
- channel?? ( local )
- invocation logic ( local )
- basis injection???
- proxy + factory?
- component descriptor
- service descriptir
- manager registratur
- Service interface + Abstract + Sample + annotation
- Configuration
- Sample REST service
- Property ( application.properties )

=== DENK NACH

insatcne:
  addresse: <meine-adresse>
  channales:
     rest http://...
     other http:// ...

serviceadress:
  channel: rest
  insatnces: a, b, c

 channelmanager pro address -> channel

 Logik:

 ServiceInstanceRegistry ( Map<service, List<ServcieInsatcne> )
   getAdresss(<component>)
      - finde alle insatcnes zu dem service
      - checke alle channels un dnehme den erste ( oder preferred )
      - return die gefuiletrte liste

  servucemanager getChannel(addtess) -> channelManager ( map<address,channel> )




  SItuation
  restchannel()
     address(service, "rest", insatcnes a, b, c) uri: e, f



     neu berechenn und vergleichen, wenn ja switch
  update
     serice neu
     service delete


NEU:
   Restchannel muss instacnes auf uris mappen ( Set )
   das kann einer oder meherer sein!

NEU: berechene serviceaddress nue und vergleiche!
